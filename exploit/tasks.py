"""
Exploitation and post-exploitation tasks.

This module contains Celery tasks for exploitation operations and
post-exploitation activities in authorized penetration testing scenarios.
"""

import asyncio
import logging
from datetime import datetime
from typing import Dict, List, Any, Optional

from celery import Task
from automation.orchestrator import celery_app
from automation.database import get_db_session, job_repository, finding_repository, asset_repository
from automation.logging_config import audit_logger, log_scan_activity
from data.schemas import ScanStatus, AssetType, SeverityLevel, VulnerabilityType, FindingStatus
from exploit.exploitation_framework import ExploitationCollector
from exploit.payload_delivery import PayloadDeliveryCollector
from exploit.post_exploitation import PostExploitationCollector


logger = logging.getLogger(__name__)


class BaseExploitTask(Task):
    """Base class for exploitation tasks."""
    
    def on_failure(self, exc, task_id, args, kwargs, einfo):
        logger.error(f"Exploit task {task_id} failed: {exc}")
    
    def on_success(self, retval, task_id, args, kwargs):
        logger.info(f"Exploit task {task_id} completed successfully")


@celery_app.task(bind=True, base=BaseExploitTask, name='exploit.tasks.run_exploitation_framework')
def run_exploitation_framework(self, job_id: str, target: str, **kwargs):
    """Run exploitation framework with proof-of-concept generation."""
    
    with get_db_session() as session:
        job_repository.update_status(session, job_id, ScanStatus.RUNNING)
    
    log_scan_activity(job_id, "exploitation_framework_started", target=target)
    
    try:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        # Run exploitation framework
        collector = ExploitationCollector()
        results = loop.run_until_complete(
            collector.collect(target, **kwargs)
        )
        
        # Process results
        findings_count = process_exploitation_results(job_id, target, results)
        
        log_scan_activity(job_id, "exploitation_framework_completed", 
                         exploits_generated=len([r for r in results if r.get('type') == 'exploitation_result']),
                         findings_count=findings_count)
        
        return {
            'target': target,
            'results': results,
            'findings_count': findings_count,
            'timestamp': datetime.utcnow().isoformat()
        }
    
    except Exception as e:
        logger.error(f"Exploitation framework failed for job {job_id}: {e}")
        log_scan_activity(job_id, "exploitation_framework_failed", error=str(e))
        raise


@celery_app.task(bind=True, base=BaseExploitTask, name='exploit.tasks.run_payload_delivery')
def run_payload_delivery(self, job_id: str, target: str, **kwargs):
    """Run payload delivery and execution engine."""
    
    with get_db_session() as session:
        job_repository.update_status(session, job_id, ScanStatus.RUNNING)
    
    log_scan_activity(job_id, "payload_delivery_started", target=target)
    
    try:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        # Run payload delivery
        collector = PayloadDeliveryCollector()
        results = loop.run_until_complete(
            collector.collect(target, **kwargs)
        )
        
        # Process results
        findings_count = process_payload_delivery_results(job_id, target, results)
        
        log_scan_activity(job_id, "payload_delivery_completed", 
                         payloads_delivered=len([r for r in results if r.get('type') == 'payload_delivery_result']),
                         findings_count=findings_count)
        
        return {
            'target': target,
            'results': results,
            'findings_count': findings_count,
            'timestamp': datetime.utcnow().isoformat()
        }
    
    except Exception as e:
        logger.error(f"Payload delivery failed for job {job_id}: {e}")
        log_scan_activity(job_id, "payload_delivery_failed", error=str(e))
        raise


@celery_app.task(bind=True, base=BaseExploitTask, name='exploit.tasks.run_post_exploitation')
def run_post_exploitation(self, job_id: str, target: str, **kwargs):
    """Run post-exploitation enumeration and persistence."""
    
    with get_db_session() as session:
        job_repository.update_status(session, job_id, ScanStatus.RUNNING)
    
    log_scan_activity(job_id, "post_exploitation_started", target=target)
    
    try:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        # Run post-exploitation
        collector = PostExploitationCollector()
        results = loop.run_until_complete(
            collector.collect(target, **kwargs)
        )
        
        # Process results
        findings_count = process_post_exploitation_results(job_id, target, results)
        
        log_scan_activity(job_id, "post_exploitation_completed", 
                         sessions_analyzed=len([r for r in results if r.get('type') == 'post_exploitation_result']),
                         findings_count=findings_count)
        
        return {
            'target': target,
            'results': results,
            'findings_count': findings_count,
            'timestamp': datetime.utcnow().isoformat()
        }
    
    except Exception as e:
        logger.error(f"Post-exploitation failed for job {job_id}: {e}")
        log_scan_activity(job_id, "post_exploitation_failed", error=str(e))
        raise


def process_exploitation_results(job_id: str, target: str, results: List[Dict[str, Any]]) -> int:
    """Process exploitation results and create findings."""
    
    findings_count = 0
    
    try:
        with get_db_session() as session:
            for result in results:
                if result.get('type') == 'exploitation_result':
                    create_exploitation_finding(session, result, job_id)
                    findings_count += 1
    
    except Exception as e:
        logger.error(f"Failed to process exploitation results: {e}")
    
    return findings_count


def process_payload_delivery_results(job_id: str, target: str, results: List[Dict[str, Any]]) -> int:
    """Process payload delivery results and create findings."""
    
    findings_count = 0
    
    try:
        with get_db_session() as session:
            for result in results:
                if result.get('type') == 'payload_delivery_result':
                    create_payload_delivery_finding(session, result, job_id)
                    findings_count += 1
                
                elif result.get('type') == 'payload_execution_result':
                    create_payload_execution_finding(session, result, job_id)
                    findings_count += 1
    
    except Exception as e:
        logger.error(f"Failed to process payload delivery results: {e}")
    
    return findings_count


def process_post_exploitation_results(job_id: str, target: str, results: List[Dict[str, Any]]) -> int:
    """Process post-exploitation results and create findings."""
    
    findings_count = 0
    
    try:
        with get_db_session() as session:
            for result in results:
                if result.get('type') == 'post_exploitation_result':
                    create_post_exploitation_finding(session, result, job_id)
                    findings_count += 1
    
    except Exception as e:
        logger.error(f"Failed to process post-exploitation results: {e}")
    
    return findings_count


def create_exploitation_finding(session, result: Dict[str, Any], job_id: str):
    """Create finding for exploitation result."""
    
    exploitation_data = result.get('exploitation', {})
    exploit_data = exploitation_data.get('exploit_data', {})
    vulnerability = exploit_data.get('vulnerability', {})
    
    exploit_type = exploit_data.get('exploit_type', 'unknown')
    target_url = exploit_data.get('target_url', '')
    
    # Map exploit type to severity
    severity_mapping = {
        'xss': SeverityLevel.MEDIUM,
        'sqli': SeverityLevel.CRITICAL,
        'rce': SeverityLevel.CRITICAL,
        'ssrf': SeverityLevel.HIGH,
        'lfi': SeverityLevel.HIGH
    }
    
    severity = severity_mapping.get(exploit_type, SeverityLevel.HIGH)
    
    finding_data = {
        'title': f"Exploitation Framework: {exploit_type.upper()} Exploit Generated",
        'description': f"Proof-of-concept exploit generated for {exploit_type.upper()} vulnerability",
        'severity': severity,
        'vulnerability_type': VulnerabilityType.INJECTION if exploit_type in ['xss', 'sqli'] else VulnerabilityType.RCE if exploit_type == 'rce' else VulnerabilityType.SSRF if exploit_type == 'ssrf' else VulnerabilityType.OTHER,
        'confidence': 0.9,  # High confidence for generated exploits
        'asset_type': AssetType.ENDPOINT,
        'asset_id': target_url,
        'affected_url': target_url,
        'evidence': [{
            'type': 'exploitation_framework',
            'exploit_type': exploit_type,
            'payloads_generated': len(exploit_data.get('payloads', [])),
            'impact_assessment': exploit_data.get('impact_assessment', {}),
            'validation_status': exploitation_data.get('status', 'generated'),
            'timestamp': exploitation_data.get('timestamp', datetime.utcnow().isoformat())
        }],
        'remediation': get_exploitation_remediation(exploit_type),
        'job_id': job_id
    }
    
    finding_repository.create(session, finding_data)


def create_payload_delivery_finding(session, result: Dict[str, Any], job_id: str):
    """Create finding for payload delivery result."""
    
    delivery_data = result.get('delivery', {})
    target = delivery_data.get('target', '')
    delivery_method = delivery_data.get('delivery_method', '')
    success = delivery_data.get('success', False)
    
    if success:
        severity = SeverityLevel.CRITICAL
        title = f"Payload Delivery Successful: {delivery_method}"
        description = f"Payload successfully delivered via {delivery_method}"
    else:
        severity = SeverityLevel.MEDIUM
        title = f"Payload Delivery Attempted: {delivery_method}"
        description = f"Payload delivery attempted via {delivery_method} (unsuccessful)"
    
    finding_data = {
        'title': title,
        'description': description,
        'severity': severity,
        'vulnerability_type': VulnerabilityType.RCE,
        'confidence': 0.8 if success else 0.5,
        'asset_type': AssetType.ENDPOINT,
        'asset_id': target,
        'affected_url': target,
        'evidence': [{
            'type': 'payload_delivery',
            'delivery_method': delivery_method,
            'payload_type': delivery_data.get('payload_type', ''),
            'success': success,
            'delivery_attempts': delivery_data.get('delivery_attempts', []),
            'timestamp': delivery_data.get('timestamp', datetime.utcnow().isoformat())
        }],
        'remediation': 'Review and secure payload delivery vectors. Implement input validation and access controls.',
        'job_id': job_id
    }
    
    finding_repository.create(session, finding_data)


def create_payload_execution_finding(session, result: Dict[str, Any], job_id: str):
    """Create finding for payload execution result."""
    
    execution_data = result.get('execution', {})
    target = result.get('target', '')
    
    success_indicators = execution_data.get('success_indicators', [])
    has_success = len(success_indicators) > 0
    
    if has_success:
        severity = SeverityLevel.CRITICAL
        title = "Payload Execution Confirmed"
        description = "Payload execution confirmed through monitoring indicators"
    else:
        severity = SeverityLevel.MEDIUM
        title = "Payload Execution Monitoring"
        description = "Payload execution monitoring completed"
    
    finding_data = {
        'title': title,
        'description': description,
        'severity': severity,
        'vulnerability_type': VulnerabilityType.RCE,
        'confidence': 0.9 if has_success else 0.3,
        'asset_type': AssetType.ENDPOINT,
        'asset_id': target,
        'affected_url': target,
        'evidence': [{
            'type': 'payload_execution',
            'execution_indicators': execution_data.get('execution_indicators', []),
            'success_indicators': success_indicators,
            'monitoring_duration': execution_data.get('monitoring_duration', 0),
            'timestamp': execution_data.get('timestamp', datetime.utcnow().isoformat())
        }],
        'remediation': 'Investigate payload execution and implement security controls to prevent unauthorized code execution.',
        'job_id': job_id
    }
    
    finding_repository.create(session, finding_data)


def create_post_exploitation_finding(session, result: Dict[str, Any], job_id: str):
    """Create finding for post-exploitation result."""
    
    post_exploit_data = result.get('post_exploitation', {})
    target = post_exploit_data.get('target', '')
    access_level = post_exploit_data.get('access_level', 'user')
    
    # Determine severity based on access level and activities
    if access_level == 'root' or access_level == 'administrator':
        severity = SeverityLevel.CRITICAL
    else:
        severity = SeverityLevel.HIGH
    
    enumeration_results = post_exploit_data.get('enumeration_results', {})
    privesc_attempts = post_exploit_data.get('privilege_escalation_attempts', [])
    persistence_established = post_exploit_data.get('persistence_established', [])
    
    finding_data = {
        'title': f"Post-Exploitation Activities: {access_level.title()} Access",
        'description': f"Post-exploitation enumeration and activities performed with {access_level} level access",
        'severity': severity,
        'vulnerability_type': VulnerabilityType.PRIVILEGE_ESCALATION,
        'confidence': 0.9,
        'asset_type': AssetType.HOST,
        'asset_id': target,
        'affected_url': target,
        'evidence': [{
            'type': 'post_exploitation',
            'access_level': access_level,
            'enumeration_categories': len(enumeration_results.get('enumeration_data', {})),
            'privesc_opportunities': len(enumeration_results.get('privilege_escalation_opportunities', [])),
            'privesc_attempts': len(privesc_attempts),
            'persistence_methods': len(persistence_established),
            'lateral_movement_targets': len(post_exploit_data.get('lateral_movement_opportunities', [])),
            'data_collected': len(post_exploit_data.get('data_collection', {})),
            'timestamp': post_exploit_data.get('timestamp', datetime.utcnow().isoformat())
        }],
        'remediation': get_post_exploitation_remediation(access_level),
        'job_id': job_id
    }
    
    finding_repository.create(session, finding_data)


def get_exploitation_remediation(exploit_type: str) -> str:
    """Get remediation advice for exploitation type."""
    
    remediation_map = {
        'xss': 'Implement output encoding, input validation, and Content Security Policy (CSP).',
        'sqli': 'Use parameterized queries, input validation, and database access controls.',
        'rce': 'Avoid system command execution with user input. Implement sandboxing and input validation.',
        'ssrf': 'Implement URL validation, whitelist allowed destinations, and network segmentation.',
        'lfi': 'Implement proper file path validation and avoid user input in file operations.'
    }
    
    return remediation_map.get(exploit_type, 'Review and remediate the exploited vulnerability using security best practices.')


def get_post_exploitation_remediation(access_level: str) -> str:
    """Get remediation advice for post-exploitation activities."""
    
    if access_level in ['root', 'administrator']:
        return 'Critical: Full system compromise detected. Perform complete incident response, system rebuild, and security assessment.'
    else:
        return 'High: Unauthorized access detected. Investigate compromise scope, patch vulnerabilities, and implement additional security controls.'
